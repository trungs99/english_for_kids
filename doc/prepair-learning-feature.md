# Role
You are a Senior Flutter Developer expert in Clean Architecture, GetX, and Isar Database.

# Context
I am building the "Learning Feature" for a Kids English Learning App.
- **Architecture:** Clean Architecture (Domain, Data, Presentation layers).
- **Core Library:** `exo_shared` (Base classes).
- **Database:** `isar_community` (Local storage).
- **DI:** GetX Bindings.
- **Service:** `IsarService` is already implemented and initialized in `main.dart`.

# Task
Implement the **Domain Layer** and **Data Layer** for the Learning Feature using Isar Database.
You must replace the hardcoded data approach in the technical spec with a dynamic local database implementation.

# 1. Data Structure & Business Logic
The data follows a strict hierarchy with sequential unlocking logic:

## A. Hierarchy
1.  **Topic** (e.g., "Warm-up", "Family")
    -   Attributes: id, name, description, thumbnailPath, orderIndex, isLocked, isCompleted.
    -   Contains: List of `Lessons`.
2.  **Lesson** (e.g., "Letter A", "Letter B")
    -   Attributes: id, title, orderIndex, isLocked, isCompleted.
    -   State: `currentStep` (Enum: Learn, Review, Test, Done).
    -   Contains: List of `Vocabularies`.
3.  **Vocabulary**
    -   Attributes: id, word, meaning (Vietnamese), imagePath, audioPath.

## B. Unlocking Logic (Critical)
1.  **Topic Locking:** Topic `n` is locked until Topic `n-1` is completed. (Topic 1 is always unlocked).
2.  **Lesson Locking:** Lesson `n` is locked until Lesson `n-1` is completed within the same Topic.
3.  **Step Locking:** A Lesson has 3 steps (Learn -> Review -> Test). User must finish the current step to unlock the next.
    -   Finish 'Test' step => Lesson is `Completed`.
    -   Finish last Lesson of Topic => Topic is `Completed` => Unlock next Topic.

# 2. Implementation Requirements

## Domain Layer (`lib/features/learning/domain/`)
* **Entities:** Pure Dart classes (`TopicEntity`, `LessonEntity`, `VocabularyEntity`). Must NOT depend on Isar.
* **Repository Interface:** `LearningRepositoryInterface`.
* **UseCases:**
    * `GetTopicsUseCase`: Fetch all topics with their hierarchy.
    * `UpdateLessonProgressUseCase`: Handle the logic of finishing a step/lesson and unlocking the next one.
    * `SeedInitialDataUseCase`: To populate the DB with initial data (Warm-up, Greetings...) if empty.

## Data Layer (`lib/features/learning/data/`)
* **Isar Models:** Classes annotated with `@collection`.
    * Use `IsarLinks` for relationships (Topic -> Lessons, Lesson -> Vocabularies).
    * **Import:** `import 'package:isar_community/isar.dart';`
* **Mappers:** Extension methods to map between `Entity` <-> `Model`.
* **DataSource:** `LearningLocalDataSource`.
    * **Constructor:** Must receive `Isar` instance (or `IsarService`) via constructor.
* **Repository Impl:** `LearningRepository` implementing the interface.

## Service Integration (`lib/core/services/isar_service.dart`)
* **Update Schema:** You must update the `IsarService.init()` method to include the new schemas: `[TopicModelSchema, LessonModelSchema, VocabularyModelSchema]`.

# 3. Code & Style Constraints
1.  **Strict Clean Architecture:** Domain Entities must not know about Isar.
2.  **Dependency Injection:**
    * In the Binding (`LearningBinding`), retrieve `IsarService` using `Get.find<IsarService>()`.
    * Pass `isarService.isar` to the `LearningLocalDataSource` constructor.
3.  **Assets:** Use `Assets.images...` (generated by flutter_gen) for image paths in the seed data.
4.  **Naming:** Follow the guide: `[name]_entity.dart`, `[name]_model.dart`, `[name]_repository.dart`.

# Output
Please generate the code for:
1.  **Isar Models** (`TopicModel`, `LessonModel`, `VocabularyModel`).
2.  **Domain Entities** (Mapped from models).
3.  **IsarService** (Updated `init` method with Schemas).
4.  **LearningLocalDataSource** (With CRUD & Seeding logic).
5.  **LearningRepository** (Implementation).
6.  **UseCases** (Focus on `UpdateLessonProgressUseCase` and `SeedInitialDataUseCase`).
7.  **DI Setup** (How to register Repository/DataSource in Binding).